<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:,">
  <title>Edytor AR Pierwiastków</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 1em;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h3>Wybierz pierwiastki:</h3>
    <form id="elementForm"></form>
    <button type="button" onclick="generateMarkers()">Generuj scenę</button>
    <button type="button" onclick="location.reload()">Wygeneruj nową scenę</button>
  </div>

  <a-scene embedded arjs="sourceType: webcam;">
    <a-assets id="assetsContainer"></a-assets>
    <a-entity id="markerContainer"></a-entity>
    <a-entity marker-interaction></a-entity>
    <a-entity camera></a-entity>
    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.7" position="1 1 0"></a-entity>
  </a-scene>

  <script>
    const API_URL = "http://localhost:3001/elements";
    let elementsData = [];
    let entities = [];
    // Definicje reakcji: symbolA+symbolB → produkt.glb
  const reactionDefinitions = {
  "C+H+H+H+H": "CH4",
  "C+O": "CO",
  "Cl+Cl": "Cl2",
  "Fe+S+S": "FeS2",
  "H+H": "H2",
  "H+H+H+N": "NH3",
  "H+O+O": "H2O",
  "HCO3+Na": "NaHCO3",  
  "N+N+O": "N2O",
  "Cl+Na": "NaCl",
   "Na+Cl+Te": "NaClTe",
  "H+Te+Cl": "HTeCl",
  "Na+Te+H": "NaTeH",
  "Ag+Br": "AgBr",
  "Al+N": "AlN",
  "Ca+O": "CaO_",
  "C+Cl+Cl+Cl+Cl": "CCl4",
  "C+O+O": "CO2",
  "Cu+Cl+Cl": "CuCl2",
  "Cu+Zn": "CuZn",
  "Fe+O+O+O": "Fe2O3",
  "Fe+Al": "FeAl",
  "H+S+H": "H2S",
  "H+Cl": "HCl",
  "H+F": "HF",
  "H+I": "HI",
  "K+Br": "KBr",
  "Mg+S": "MgS",
  "N+O+O": "NO2",
  "Pb+S": "PbS",
  "P+Cl+Cl+Cl": "PCl3",
  "S+F+F+F+F+F+F": "SF6",
  "Si+O+O": "SiO2",
  "Zn+Cl+Cl": "ZnCl2",
  "Na+H+Te": "NaHTe"      
};

const reactionNames = {
  "CH4": "metan",
  "CO": "tlenek węgla(II) (czad)",
  "Cl2": "chlor (cząsteczkowy)",
  "FeS2": "disiarczek żelaza (piryt)",
  "H2": "wodór (cząsteczkowy)",
  "NH3": "amoniak",
  "H2O": "woda",
  "NaHCO3": "wodorowęglan sodu (soda oczyszczona)",
  "N2O": "podtlenek azotu (gaz rozweselający)",
  "NaCl": "chlorek sodu (sol kuchenna)",
  "NaClTe": "chlortellurek sodu (hipotetyczny)",
  "HTeCl": "chlorek tellurowodoru (hipotetyczny)",
  "NaTeH": "wodorko-tellurek sodu",
  "AgBr": "bromek srebra",
  "AlN": "azotek glinu",
  "CaO_": "tlenek wapnia",
  "CCl4": "czterochlorek węgla",
  "CO2": "dwutlenek węgla",
  "CuCl2": "chlorek miedzi(II)",
  "CuZn": "mosiądz (stop miedzi i cynku)",
  "Fe2O3": "tlenek zelaza(III)",
  "FeAl": "stop zelaza i aluminium",
  "H2S": "siarkowodór",
  "HCl": "kwas solny (chlorowodór)",
  "HF": "kwas fluorowodorowy",
  "HI": "kwas jodowodorowy",
  "KBr": "bromek potasu",
  "MgS": "siarczek magnezu",
  "NO2": "dwutlenek azotu",
  "PbS": "siarczek olowiu(II)",
  "PCl3": "trojchlorek fosforu",
  "SF6": "szesciofluorek siarki",
  "SiO2": "dwutlenek krzemu (krzemionka)",
  "ZnCl2": "chlorek cynku",
  "NaHTe": "wodorko-tellurek sodu"
};




    async function loadElements() {
      try {
        const res = await fetch(API_URL);
        elementsData = await res.json();

        const form = document.getElementById('elementForm');
        form.innerHTML = '';
        elementsData.forEach(el => {
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = 'element';
          cb.value = el.atomic_number;

          const label = document.createElement('label');
          label.textContent = `${el.symbol} (${el.atomic_number})`;
          label.prepend(cb);

          const div = document.createElement('div');
          div.appendChild(label);
          form.appendChild(div);
        });
      } catch (error) {
        console.error("Błąd ładowania danych pierwiastków:", error);
      }
    }

  function generateMarkers() {
  const selected = [...document.querySelectorAll('input[name="element"]:checked')];
  const markerContainer = document.getElementById('markerContainer');
  const assetsContainer = document.getElementById('assetsContainer');

  markerContainer.innerHTML = '';
  assetsContainer.innerHTML = '';
  pairs = [];
  document.querySelectorAll('[gltf-model^="#reaction-"]').forEach(e => e.remove());

  const minScale = 0.3;
  const maxScale = 0.7;
  entities = [];

  selected.forEach(input => {
    const element = elementsData.find(el => el.atomic_number == input.value);
    if (!element) return;

    const asset = document.createElement('a-asset-item');
    asset.setAttribute('id', `model${element.atomic_number}`);
    asset.setAttribute('src', `models/${element.atomic_number}.glb`);
    assetsContainer.appendChild(asset);

    const normalized = (element.atomic_number - 1) / (118 - 1);
    const finalScale = Math.min(0.5, minScale + normalized * (maxScale - minScale));
    const scaleStr = `${finalScale} ${finalScale} ${finalScale}`;

    const marker = document.createElement('a-marker');
    marker.setAttribute('type', 'pattern');
    marker.setAttribute('url', `markers/${element.atomic_number}.patt`);
    marker.setAttribute('emitevents', 'true');

    const wrapper = document.createElement('a-entity');
    wrapper.setAttribute('id', `atom-wrapper-${element.symbol}`);
    wrapper.setAttribute('position', '0 0 0');

    const entity = document.createElement('a-entity');
    entity.setAttribute('gltf-model', `#model${element.atomic_number}`);
    entity.setAttribute('scale', scaleStr);
    entity.setAttribute('position', '0 0 0');
    entity.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 6000');

    wrapper.appendChild(entity);
    wrapper.object3D.visible = false;
    marker.appendChild(wrapper);
    markerContainer.appendChild(marker);

    const entityData = {
      entity: wrapper,
      symbol: element.symbol.trim(),
      isVisible: false
    };
    entities.push(entityData);

    marker.addEventListener('markerFound', () => {
      console.log(`✅ markerFound: ${element.symbol}`);
      wrapper.object3D.visible = true;
      entityData.isVisible = true;
    });

    marker.addEventListener('markerLost', () => {
      console.log(`❌ markerLost: ${element.symbol}`);
       if (wrapper.dataset?.locked === "true") return;
      wrapper.object3D.visible = false;
      entityData.isVisible = false;
    });
  }); // ⬅️ KONIEC pętli selected.forEach

 

  // ✅ Tworzymy pary do analizy w tick()
  setTimeout(() => {
    for (let i = 0; i < entities.length; i++) {
      for (let j = i + 1; j < entities.length; j++) {
        const pairAB = {
          a: entities[i].entity,
          b: entities[j].entity,
          symbolA: entities[i].symbol,
          symbolB: entities[j].symbol,
          isVisibleA: () => entities[i].isVisible,
          isVisibleB: () => entities[j].isVisible,
          visibleSince: null
        };
        const pairBA = {
          a: entities[j].entity,
          b: entities[i].entity,
          symbolA: entities[j].symbol,
          symbolB: entities[i].symbol,
          isVisibleA: () => entities[j].isVisible,
          isVisibleB: () => entities[i].isVisible,
          visibleSince: null
        };
        pairs.push(pairAB, pairBA);
      }
    }
  }, 100);
}
function getBestReaction(visibleSymbols) {
  const counts = {};
  visibleSymbols.forEach(el => counts[el] = (counts[el] || 0) + 1);

  let bestMatch = null;

  for (const key of Object.keys(reactionDefinitions)) {
    const keyAtoms = key.split('+');
    const keyCounts = {};

    // zliczamy wymagane pierwiastki w tej reakcji
    for (const atom of keyAtoms) {
      keyCounts[atom] = (keyCounts[atom] || 0) + 1;
    }

    // sprawdzamy czy wystarcza pierwiastków do tej reakcji
    let match = true;
    for (const atom in keyCounts) {
      if (!counts[atom] || counts[atom] < keyCounts[atom]) {
        match = false;
        break;
      }
    }

    // jeśli pasuje i jest dłuższa niż obecna najlepsza – zapisz
    if (match) {
      if (!bestMatch || keyAtoms.length > bestMatch.split('+').length) {
        bestMatch = key;
      }
    }
  }

  return bestMatch;
}



    AFRAME.registerComponent('marker-interaction', {
      init: function () {
        this.createdFusions = new Set();
        this.enabled = false;
        setTimeout(() => { this.enabled = true; }, 2000);
      },

tick: function () {
  if (!this.enabled) return;
  if (document.querySelector('.reaction-label')) return;

  const visibleSymbols = [];
  const visibleEntities = [];

  for (let e of entities) {
    if (e.isVisible) {
      visibleSymbols.push(e.symbol);
      visibleEntities.push(e.entity);
    }
  }

  if (visibleSymbols.length < 2) return;

  const reactionMatch = getBestReaction(visibleSymbols);
  if (!reactionMatch || this.createdFusions.has(reactionMatch)) return;
  this.createdFusions.add(reactionMatch);
  const reactionKey = reactionMatch;
  const product = reactionDefinitions[reactionKey];

  // Oblicz środek widocznych modeli
  let center = new THREE.Vector3();
  visibleEntities.forEach(ent => {
    let pos = new THREE.Vector3();
    ent.object3D.getWorldPosition(pos);
    center.add(pos);
  });
  center.divideScalar(visibleEntities.length);

  const distanceToStop = 0.15;

  // Przenieś kopie modeli do sceny i odłącz od markerów
  visibleEntities.forEach(ent => {
    const originalModel = ent.querySelector('[gltf-model]');
    if (!originalModel) return;

    const cloned = document.createElement('a-entity');
    cloned.setAttribute('gltf-model', originalModel.getAttribute('gltf-model'));
    cloned.setAttribute('scale', originalModel.getAttribute('scale'));
    cloned.setAttribute('animation', originalModel.getAttribute('animation'));

   // Oblicz pozycję docelową
let from = new THREE.Vector3();
ent.object3D.getWorldPosition(from);

// Automatyczne dostosowanie radius w zależności od wielkości atomów
const maxAtomicNumber = Math.max(...visibleSymbols.map(sym => {
  const el = elementsData.find(e => e.symbol === sym);
  return el ? el.atomic_number : 1;
}));

let radius = 0.18;
if (maxAtomicNumber >= 90) {
  radius = 0.5;
} else if (maxAtomicNumber >= 50) {
  radius = 0.35;
} else if (maxAtomicNumber >= 20) {
  radius = 0.25;
} else {
  radius = 0.18;
}

const angleOffset = (Math.PI * 2 / visibleEntities.length) * visibleEntities.indexOf(ent);
const offset = new THREE.Vector3(
  Math.cos(angleOffset) * radius,
  0,
  Math.sin(angleOffset) * radius
);
const to = new THREE.Vector3(center.x + offset.x, center.y, center.z + offset.z);

    // Umieść w scenie
    cloned.setAttribute('position', `${from.x} ${from.y} ${from.z}`);
    ent.sceneEl.appendChild(cloned);

    // Animacja do punktu
    let step = 0;
    const steps = 30;
    const interval = setInterval(() => {
      step++;
      const lerped = new THREE.Vector3().lerpVectors(from, to, step / steps);
      cloned.setAttribute('position', `${lerped.x} ${lerped.y} ${lerped.z}`);
      if (step >= steps) clearInterval(interval);
    }, 30);
  });

  // Dodaj dymek z opisem reakcji
  const bubble = document.createElement('a-entity');
  bubble.setAttribute('position', `${center.x} ${center.y + 1.2} ${center.z}`);
  bubble.setAttribute('look-at', '[camera]');
  bubble.classList.add('reaction-label');

  const background = document.createElement('a-plane');
  background.setAttribute('height', '0.6');
  background.setAttribute('width', '3.6');
  background.setAttribute('color', '#f0f0f0');
  background.setAttribute('opacity', '0.95');
  background.setAttribute('material', 'shader: flat; side: double');
  background.setAttribute('transparent', 'true');
  background.setAttribute('position', '0 0 0');
  bubble.appendChild(background);

  const formattedReaction = reactionMatch.replace(/\+/g, ' + ') + ' → ' + product;
  const name = reactionNames[product] || product;

  const label = document.createElement('a-text');
  label.setAttribute('value', `${formattedReaction}\n(${name})`);
  label.setAttribute('align', 'center');
  label.setAttribute('color', '#000000');
  label.setAttribute('width', '3.2');
  label.setAttribute('wrap-count', '30');
  label.setAttribute('baseline', 'center');
  label.setAttribute('font', 'https://cdn.aframe.io/fonts/Exo2Bold.fnt');
  label.setAttribute('position', '0 0 0.05');
  label.setAttribute('look-at', '[camera]');
  bubble.appendChild(label);

  bubble.setAttribute('animation', {
    property: 'position',
    dir: 'alternate',
    dur: 30000,
    to: `${center.x} ${center.y + 1.3} ${center.z}`
  });

  bubble.setAttribute('animation__scale', {
    property: 'scale',
    from: '0 0 0',
    to: '1 1 1',
    dur: 400,
    easing: 'easeOutElastic'
  });

  this.el.sceneEl.appendChild(bubble);

  setTimeout(() => {
    bubble.remove();
  }, 30000);

  console.log(`✅ Reakcja: ${formattedReaction}`);
}


    });

    window.addEventListener('DOMContentLoaded', loadElements);
  </script>
</body>
</html>
